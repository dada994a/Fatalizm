package we.devs.forever.client.modules.impl.exploit;

import net.minecraft.block.Block;
import net.minecraft.block.BlockChest;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityItemFrame;
import net.minecraft.entity.passive.AbstractChestHorse;
import net.minecraft.init.Items;
import net.minecraft.item.Item;
import net.minecraft.item.ItemBlock;
import net.minecraft.item.ItemShulkerBox;
import net.minecraft.item.ItemStack;
import net.minecraft.util.EnumHand;
import we.devs.forever.client.command.api.Command;
import we.devs.forever.client.modules.api.Module;
import we.devs.forever.client.setting.Setting;

import java.util.Comparator;

public class AutoDupe extends Module {
    public Setting<Mode> mode = (new Setting<>("Mode", Mode.Frame));
    public Setting<Boolean> shulkersonly = (new Setting<>("ShulkersOnly", true, "Client will dupe only shulkers", v -> mode.getValue() == Mode.Frame));
    public Setting<Float> range = (new Setting<>("Range", 5.0f, 0.0f, 6.0f, "Range of the frame where client dupes", v -> mode.getValue() == Mode.Frame));
    public Setting<Float> turns = (new Setting<>("Turns", 1.0f, 0.0f, 3.0f, "quantity of turns client need to do and hit the shulker", v -> mode.getValue() == Mode.Frame));
    public Setting<Float> ticks = (new Setting<>("Ticks", 10.0f, 1.0f, 20.0f, "quantity of ticks client need to do and hit the shulker", v -> mode.getValue() == Mode.Frame));
    Entity donkey;
    private int timeout_ticks = 0;
    public AutoDupe() {
        super("AutoDupe", "Auto dupes", Category.EXPLOIT);
    }

    @Override
    public void onEnable() {
        if (this.mode.getValue() == Mode.Saddle) {
            if (this.findAirInHotbar() == -1) {
                this.disable();
                return;
            }
            if (this.findChestInHotbar() == -1) {
                this.disable();
                return;
            }
            this.donkey = AutoDupe.mc.world.loadedEntityList.stream().filter(this::isValidEntity).min(Comparator.comparing(p_Entity -> (AutoDupe.mc.player.getDistance(p_Entity)))).orElse(null);
            if (this.donkey == null) {
                this.disable();
            }
        }
    }

    @Override
    public void onUpdate() {
        if (this.mode.getValue() == Mode.Frame) {
            if (mc.player != null && mc.world != null) {

                if (this.shulkersonly.getValue()) {
                    int shulker_slot = getShulkerSlot();
                    if (shulker_slot != -1) {
                        mc.player.inventory.currentItem = shulker_slot;
                    }
                }
                for (Entity frame : mc.world.loadedEntityList) {
                    if (frame instanceof EntityItemFrame) {
                        if (mc.player.getDistance(frame) <= this.range.getValue()) {
                            if (timeout_ticks >= this.ticks.getValue()) {
                                if (((EntityItemFrame) frame).getDisplayedItem().getItem() == Items.AIR && !mc.player.getHeldItemMainhand().isEmpty) {
                                    mc.playerController.interactWithEntity(mc.player, frame, EnumHand.MAIN_HAND);
                                }
                                if (((EntityItemFrame) frame).getDisplayedItem().getItem() != Items.AIR) {
                                    for (int i = 0; i < this.turns.getValue(); i++) {
                                        mc.playerController.interactWithEntity(mc.player, frame, EnumHand.MAIN_HAND);
                                    }
                                    mc.playerController.attackEntity(mc.player, frame);
                                    timeout_ticks = 0;
                                }
                            }
                            ++timeout_ticks;
                        }
                    }
                }
            }
        }
        if (this.mode.getValue() == Mode.Saddle) {
            if (this.findAirInHotbar() == -1) {
                this.disable();
                return;
            }
            if (this.findChestInHotbar() == -1) {
                this.disable();
                return;
            }
            this.donkey = AutoDupe.mc.world.loadedEntityList.stream().filter(this::isValidEntity).min(Comparator.comparing(p_Entity -> (AutoDupe.mc.player.getDistance(p_Entity)))).orElse(null);
            if (this.donkey == null) {
                this.disable();
                return;
            }
            this.putChestOn();
            Command.sendMessage("put chest on the donkey");
            this.toggle();
        }
    }

    private int getShulkerSlot() {
        int shulker_slot = -1;
        for (int i = 0; i < 9; i++) {
            Item item = mc.player.inventory.getStackInSlot(i).getItem();
            if (item instanceof ItemShulkerBox) shulker_slot = i;
        }
        return shulker_slot;
    }

    public void putChestOn() {
        AutoDupe.mc.player.inventory.currentItem = this.findAirInHotbar();
        AutoDupe.mc.player.inventory.currentItem = this.findChestInHotbar();
        AutoDupe.mc.playerController.interactWithEntity(AutoDupe.mc.player, this.donkey, EnumHand.MAIN_HAND);
    }

    private int findChestInHotbar() {
        int slot = -1;
        for (int i = 0; i < 9; ++i) {
            Block block;
            ItemStack stack = AutoDupe.mc.player.inventory.getStackInSlot(i);
            if (stack == ItemStack.EMPTY || !(stack.getItem() instanceof ItemBlock) || !((block = ((ItemBlock) stack.getItem()).getBlock()) instanceof BlockChest))
                continue;
            slot = i;
            break;
        }
        return slot;
    }

    private int findAirInHotbar() {
        int slot = -1;
        for (int i = 0; i < 9; ++i) {
            ItemStack stack = AutoDupe.mc.player.inventory.getStackInSlot(i);
            if (stack.getItem() != Items.AIR) continue;
            slot = i;
        }
        return slot;
    }

    private boolean isValidEntity(Entity entity) {
        if (entity instanceof AbstractChestHorse) {
            AbstractChestHorse donkey = (AbstractChestHorse) entity;
            return !donkey.isChild() && donkey.isTame();
        }
        return false;
    }

    public enum Mode {
        Frame,
        Saddle
    }

}