package we.devs.forever.client.modules.impl.exploit;

import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Items;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import we.devs.forever.api.event.events.network.PacketEvent;
import we.devs.forever.api.event.events.world.BlockEvent;
import we.devs.forever.api.event.eventsys.annotated.handler.annotation.EventListener;
import we.devs.forever.api.util.client.TimerUtil;
import we.devs.forever.client.modules.api.Module;
import we.devs.forever.client.setting.Setting;

public class InstantMine extends Module {
    public InstantMine() {
        super("InstantMine", "shit", Category.EXPLOIT);
    }

    private BlockPos renderBlock;
    private BlockPos lastBlock;
    private boolean packetCancel = false;
    private final TimerUtil breaktimer = new TimerUtil();
    private EnumFacing direction;

    public Setting<Boolean> autoBreak = (new Setting<>("AutoBreak", true));
    public Setting<Integer> delay = (new Setting<>("Delay", 20, 0, 300));
    public Setting<Boolean> picOnly = (new Setting<>("OnlyPickaxe", true));
    //public Setting<Integer> red = (new Setting<>("Red", 255, 0, 255));
    //public Setting<Integer> green = (new Setting<>("Green", 255, 0, 255));
    //public Setting<Integer> blue = (new Setting<>("Blue", 0, 0, 255));
    //public Setting<Integer> alpha = (new Setting<>("Alpha", 70, 0, 255));
/*
    @EventListener
    public void onRender3D(Render3DEvent event) {
        if (renderBlock != null) {
            drawBlock(renderBlock, red.get_value(1), green.get_value(1), blue.get_value(1), alpha.get_value(1));
        }
    }

    private void drawBlock(BlockPos blockPos, int r, int g, int b, int a) {
        RenderHelp.prepare("quads");
        //RenderUtil.drawBox(blockPos, new Color(r, g, b, a), true, true);
        Renderer3D.drawBoxESP(bb, new Color((int) (color.getColor().getRed() * progress), (int) (readyColor.getColor().getGreen() * (1 - progress)), color.getColor().getBlue()), 1f, true, true, color.getColor().getAlpha(), 255);
        RenderHelp.release();
    }
 */

    @Override
    public void onUpdate() {
        if(renderBlock != null) {
            if(autoBreak.getValue() && breaktimer.passedMs(delay.getValue())) {
                if(picOnly.getValue()&&!(mc.player.getHeldItem(EnumHand.MAIN_HAND).getItem() == Items.DIAMOND_PICKAXE)) return;
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                        renderBlock, direction));
                breaktimer.reset();
            }

        }

        try {
            mc.playerController.blockHitDelay = 0;

        } catch (Exception ignored) {
        }
    }

    @EventListener
    public void onPacketSend(PacketEvent.Send event) {
        Packet packet = event.getPacket();
        if (packet instanceof CPacketPlayerDigging) {
            if(((CPacketPlayerDigging) packet).getAction()== CPacketPlayerDigging.Action.START_DESTROY_BLOCK && packetCancel) event.setCanceled(true);
        }
    }

    @EventListener
    public void onBlockEvent(BlockEvent event) {
        if (canBreak(event.getPos())) {
            if (lastBlock==null||event.getPos().getX()!=lastBlock.getX() || event.getPos().getY()!=lastBlock.getY() || event.getPos().getZ()!=lastBlock.getZ()) {
                packetCancel = false;
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK,
                        event.getPos(), event.getEnumFacing()));
            }
            packetCancel = true;
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                    event.getPos(), event.getEnumFacing()));
            renderBlock = event.getPos();
            lastBlock = event.getPos();
            direction = event.getEnumFacing();
            event.setCanceled(true);
        }
    }

    private boolean canBreak(BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();

        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

    public BlockPos getTarget(){
        return renderBlock;
    }

    public void setTarget(BlockPos pos){
        renderBlock = pos;
        packetCancel = false;
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK,
                pos, EnumFacing.DOWN));
        packetCancel = true;
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                pos, EnumFacing.DOWN));
        direction = EnumFacing.DOWN;
        lastBlock = pos;
    }
}