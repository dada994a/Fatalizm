package we.devs.forever.client.modules.impl.exploit;


import net.minecraft.client.gui.GuiDownloadTerrain;
import net.minecraft.entity.item.EntityBoat;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.Vec3i;
import we.devs.forever.api.event.events.network.PacketEvent;
import we.devs.forever.api.event.events.player.*;
import we.devs.forever.api.event.eventsys.annotated.handler.annotation.EventListener;
import we.devs.forever.api.util.client.TimeVec3d;
import we.devs.forever.api.util.player.PlayerUtil;
import we.devs.forever.client.modules.api.Module;
import we.devs.forever.client.modules.impl.exploit.packetfly.PacketFly;
import we.devs.forever.client.setting.Setting;
import we.devs.forever.mixin.mixins.accessor.ISPacketPlayerPosLook;

import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

public class Phase extends Module {
    private final Setting<Mode> mode = (new Setting<>("Mode", Mode.Sand));
    private final Setting<Double> speed = (new Setting<>("Speed", 1D, 0.1, 10D, V -> mode.getValue().equals(Mode.NoClip2)));
    private final Setting<Boolean> noVoid = (new Setting<>("NoVoid", true));
    private final Setting<Boolean> autoClip = (new Setting<>("AutoClip", false));
    private final Setting<Double> distance = (new Setting<>("Distance", 6D, 0.1, 10D));

    private enum Mode {
        Sand, NoClip, NoClip2
    }

    private int teleportId = 0;

    private final ArrayList<CPacketPlayer> packets = new ArrayList<>();
    private final Map<Integer, TimeVec3d> posLooks = new ConcurrentHashMap<>();

    double speedX = 0;
    double speedY = 0;
    double speedZ = 0;

    public Phase() {
        super("Phase", "Non Full-Block Phase", Module.Category.EXPLOIT);
    }

    @Override
    public String getDisplayInfo() {
        return mode.getValue().name();
    }

    @EventListener
    public void onAddCollisionBoxToList(BlockCollisionBoundingBoxEvent event) {
        if (mc.player == null || mc.world == null) return;
        if (mode.getValue() == Mode.Sand) {
            if (mc.player.getRidingEntity() != null && event.getEntity() == mc.player.getRidingEntity()) {
                if (mc.gameSettings.keyBindSprint.isKeyDown() && noVoid.getValue()) {
                    event.cancel();
                } else {
                    if (mc.gameSettings.keyBindJump.isKeyDown() && event.getPos().getY() >= mc.player.getRidingEntity().posY) {
                        event.cancel();
                    }
                    if (event.getPos().getY() >= mc.player.getRidingEntity().posY) {
                        event.cancel();
                    }
                }
            }
        } else {
            if (event.getEntity() == mc.player || mc.player.getRidingEntity() != null && event.getEntity() == mc.player.getRidingEntity()) {
                event.cancel();
            }
        }
    }

    @EventListener
    public void onUpdateWalkingPlayer(MotionEvent.Pre event) {
        if (mode.getValue() == Mode.NoClip) {
            mc.player.setVelocity(0, 0, 0);
            if (mc.gameSettings.keyBindForward.isKeyDown() || mc.gameSettings.keyBindBack.isKeyDown() || mc.gameSettings.keyBindLeft.isKeyDown() || mc.gameSettings.keyBindRight.isKeyDown()) {
                final double[] speed = PlayerUtil.directionSpeed(0.06f);
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX + speed[0], mc.player.posY, mc.player.posZ + speed[1], mc.player.onGround));
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, 0, mc.player.posZ, mc.player.onGround));
            }
            if (mc.gameSettings.keyBindSneak.isKeyDown()) {
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY - (distance.getValue() / 1000), mc.player.posZ, mc.player.onGround));
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, 0, mc.player.posZ, mc.player.onGround));
            }

            if (mc.gameSettings.keyBindJump.isKeyDown()) {
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY + (distance.getValue() / 1000), mc.player.posZ, mc.player.onGround));
                mc.player.connection.sendPacket(new CPacketPlayer.Position(mc.player.posX, 0, mc.player.posZ, mc.player.onGround));
            }
        }
    }

    @EventListener
    public void onBlockPushOut(PushEvent event) {
        event.cancel();
    }

    @EventListener
    public void onUpdate(PlayerUpdateEvent event) {
        if (mode.getValue() == Mode.Sand) {
            if (mc.gameSettings.keyBindJump.isKeyDown()) {
                if (mc.player.getRidingEntity() != null && mc.player.getRidingEntity() instanceof EntityBoat) {
                    final EntityBoat boat = (EntityBoat) mc.player.getRidingEntity();
                    if (boat.onGround) {
                        boat.motionY = 0.42f;
                    }
                }
            }
        }
        if (mode.getValue() == Mode.NoClip2) {
            if (mc.player.ticksExisted % 20 == 0) {
                cleanPosLooks();
            }

            mc.player.setVelocity(0.0D, 0.0D, 0.0D);

            if (teleportId <= 0) {
                CPacketPlayer startingOutOfBoundsPos = new CPacketPlayer.Position(mc.player.posX, mc.player.posY + PacketFly.randomLimitedVertical(), mc.player.posZ, mc.player.onGround);
                packets.add(startingOutOfBoundsPos);
                mc.player.connection.sendPacket(startingOutOfBoundsPos);
            }

            double[] dir = PlayerUtil.directionSpeed(speed.getValue());

            speedX = dir[0];
            speedY = 0;
            speedZ = dir[1];

            Vec3d newPos = new Vec3d(mc.player.posX + speedX, mc.player.posY, mc.player.posZ + speedZ);
            Vec3d blockCenter = new Vec3d(Math.floor(mc.player.posX), Math.floor(mc.player.posY), Math.floor(mc.player.posZ)).add(0.5, 0, 0.5);

            Vec3d min = newPos.subtract(0.3, 0, 0.3);
            Vec3d max = newPos.add(0.3, 0, 0.3);

            Vec3i minI = new Vec3i(Math.floor(min.x), Math.floor(min.y), Math.floor(min.z));
            Vec3i maxI = new Vec3i(Math.floor(max.x), Math.floor(max.y), Math.floor(max.z));

            if (!minI.equals(maxI) && newPos.distanceTo(blockCenter) > mc.player.getPositionVector().distanceTo(blockCenter)) {
                dir = PlayerUtil.directionSpeed(0.062);
                speedX = dir[0];
                speedY = 0;
                speedZ = dir[1];
                CPacketPlayer move = new CPacketPlayer.Position(mc.player.posX + speedX, mc.player.posY + speedY, mc.player.posZ + speedZ, mc.player.onGround);
                packets.add(move);
                mc.player.connection.sendPacket(move);
                CPacketPlayer extremeMove = new CPacketPlayer.Position(mc.player.posX + speedX, mc.player.posY + PacketFly.randomLimitedVertical(), mc.player.posZ + speedZ, mc.player.onGround);
                packets.add(extremeMove);
                mc.player.connection.sendPacket(extremeMove);
                teleportId++;
                mc.player.connection.sendPacket(new CPacketConfirmTeleport(teleportId));
                posLooks.put(teleportId, new TimeVec3d(mc.player.posX, mc.player.posY, mc.player.posZ, System.currentTimeMillis()));
            } else {
                CPacketPlayer move = new CPacketPlayer.Position(newPos.x, newPos.y, newPos.z, mc.player.onGround);
                packets.add(move);
                mc.player.connection.sendPacket(move);
            }

            mc.player.setVelocity(speedX, speedY, speedZ);
        }
    }

    public void onEnable() {
        if (autoClip.getValue()) {
            if (mc.player != null && mc.world != null) {
                double cos = Math.cos(Math.toRadians(mc.player.rotationYaw + 90.0f));
                double sin = Math.sin(Math.toRadians(mc.player.rotationYaw + 90.0f));
                mc.player.setPosition(mc.player.posX + (1.0 * (distance.getValue() / 1000) * cos + 0.0 * (distance.getValue() / 1000) * sin), mc.player.posY, mc.player.posZ + (1.0 * (distance.getValue() / 1000) * sin - 0.0 * (distance.getValue() / 1000) * cos));
            }
        }
    }


    @EventListener
    public void onPlayerMove(MoveEvent event) {
        if (mode.getValue() == Mode.NoClip2) {
            event.setX(speedX);
            event.setY(speedY);
            event.setZ(speedZ);
        }
    }

    @EventListener
    public void onSend(PacketEvent.Send event) {
        if (mode.getValue() == Mode.NoClip2) {
            if (event.getPacket() instanceof CPacketPlayer && !(event.getPacket() instanceof CPacketPlayer.Position)) {
                event.cancel();
            }
            if (event.getPacket() instanceof CPacketPlayer) {
                CPacketPlayer packet = (CPacketPlayer) event.getPacket();
                if (this.packets.contains(packet)) {
                    this.packets.remove(packet);
                    return;
                }
                event.cancel();
            }
        }
    }

    @EventListener
    public void onReceive(PacketEvent.Receive event) {
        if (mode.getValue() == Mode.NoClip2) {
            if (event.getPacket() instanceof SPacketPlayerPosLook) {
                if (!(mc.currentScreen instanceof GuiDownloadTerrain)) {
                    SPacketPlayerPosLook packet = (SPacketPlayerPosLook) event.getPacket();
                    if (mc.player.isEntityAlive()) {
                        if (this.teleportId <= 0) {
                            this.teleportId = ((SPacketPlayerPosLook) event.getPacket()).getTeleportId();
                        } else {
                            if (mc.world.isBlockLoaded(new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ), false)) {
                                if (posLooks.containsKey(packet.getTeleportId())) {
                                    TimeVec3d vec = posLooks.get(packet.getTeleportId());
                                    if (vec.x == packet.getX() && vec.y == packet.getY() && vec.z == packet.getZ()) {
                                        posLooks.remove(packet.getTeleportId());
                                        event.cancel();
                                        return;
                                    }
                                }
                            }
                        }
                    }
                    ((ISPacketPlayerPosLook) packet).setYaw(mc.player.rotationYaw);
                    ((ISPacketPlayerPosLook) packet).setPitch(mc.player.rotationPitch);
                    packet.getFlags().remove(SPacketPlayerPosLook.EnumFlags.X_ROT);
                    packet.getFlags().remove(SPacketPlayerPosLook.EnumFlags.Y_ROT);
                    teleportId = packet.getTeleportId();
                } else {
                    teleportId = 0;
                }
            }
        }
    }

    private void cleanPosLooks() {
        posLooks.forEach((tp, timeVec3d) -> {
            if (System.currentTimeMillis() - timeVec3d.getTime() > TimeUnit.SECONDS.toMillis(30L)) {
                posLooks.remove(tp);
            }
        });
    }

    public void onDisable() {
        mc.player.noClip = false;
    }
}
