package we.devs.forever.client.modules.impl.exploit.speedmine;


import net.minecraft.block.Block;
import net.minecraft.block.material.Material;
import net.minecraft.block.state.IBlockState;
import net.minecraft.enchantment.EnchantmentHelper;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.init.Blocks;
import net.minecraft.init.Enchantments;
import net.minecraft.init.Items;
import net.minecraft.init.MobEffects;
import net.minecraft.item.ItemStack;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.play.client.CPacketPlayerTryUseItemOnBlock;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.AxisAlignedBB;
import net.minecraft.util.math.BlockPos;
import we.devs.forever.api.event.events.network.PacketEvent;
import we.devs.forever.api.event.events.player.MotionEvent;
import we.devs.forever.api.event.events.player.ProcessRightClickBlockEvent;
import we.devs.forever.api.event.events.world.BlockEvent;
import we.devs.forever.api.event.events.world.BlockResetEvent;
import we.devs.forever.api.event.eventsys.annotated.handler.annotation.EventListener;
import we.devs.forever.api.util.enums.AutoSwitch;
import we.devs.forever.api.util.math.CalcUtil;
import we.devs.forever.api.util.player.RotationType;
import we.devs.forever.api.util.player.inventory.InventoryUtil;
import we.devs.forever.api.util.player.inventory.SwitchUtil;
import we.devs.forever.api.util.render.RenderUtil;
import we.devs.forever.api.util.world.BlockUtil;
import we.devs.forever.client.command.api.Command;
import we.devs.forever.client.modules.api.Module;
import we.devs.forever.client.modules.impl.combat.autocrystalold.AutoCrystal;
import we.devs.forever.client.modules.impl.combat.autocrystalold.util.AutoCrystalQueue;
import we.devs.forever.client.modules.impl.exploit.speedmine.enums.PlaceMode;
import we.devs.forever.client.modules.impl.exploit.speedmine.enums.RenderMode;
import we.devs.forever.client.modules.impl.exploit.speedmine.utils.Renderer3D;
import we.devs.forever.client.setting.Setting;
import we.devs.forever.client.ui.foreverClientGui.components.items.buttons.ColorPickerButton;
import we.devs.forever.mixin.mixins.accessor.IPlayerControllerMP;

import java.awt.*;


public class SpeedMine extends Module {
    public static SpeedMine speedMine;
    public Setting<AutoSwitch> silent = (new Setting<>("Silent", AutoSwitch.None));
    public Setting<PlaceMode> placeMode = (new Setting<>("Place Mode", PlaceMode.Manual));
    public Setting<Boolean> rotate = (new Setting<>("Rotate", false, "Rotate you to your current break pos"));
    public Setting<Boolean> strict = (new Setting<>("Strict", true, "Strict checks for strict servers like 2bpvp"));
    public Setting<Boolean> reBreak = (new Setting<>("ReBreak", true, "Allow you to rebreake your current break pos"));
    public Setting<Boolean> strictReBreak = (new Setting<>("StrictReBreak", false, "Break only once, excluded anvil, shulkers and echests", v -> reBreak.getValue()));
    public Setting<Boolean> noReset = (new Setting<>("NoReset", true, "Deny you to reset your break progress. \nRecommend use with MultiTask"));
    public Setting<Boolean> resetOnPlace = (new Setting<>("ResetOnPlace", false, "Reset current break pos if you place block on current pos"));
    public Setting<Boolean> abort = (new Setting<>("Abort", false, "Reset current break pos if you place block on current pos"));
    public Setting<Boolean> reset = (new Setting<>("Reset", true, "Reset current break pos if you place block on current pos"));

    public Setting<Integer> range = (new Setting<>("Range", 6, 1, 30, "Range for SpeedMine"));
    public Setting<Float> speed = (new Setting<>("Speed", 0.8f, 0.1f, 1f, "How fast do you need break the block"));
    public Setting<Integer> spam = (new Setting<>("Packet Spam", 1, 1, 10, "Spam to server packets for start break block"));
    public Setting<RenderMode> renderMode = (new Setting<>("Render Mode", RenderMode.Fade, "Render mode for SpeedMine"));
    public Setting<Boolean> showProgress = (new Setting<>("Show Progress", false, "Show current progress", V -> renderMode.getValue() != RenderMode.None));
    public Setting<Color> color = (new Setting<>("StartColor", new Color(255, 0, 0, 75), ColorPickerButton.Mode.Normal, 100));
    public Setting<Color> readyColor = (new Setting<>("EndColor", new Color(0, 255, 0, 75), ColorPickerButton.Mode.Normal, 100));
    public Setting<Boolean> debug = (new Setting<>("Debug", false, ""));
    public boolean swap = false,
            checked,
            strictCheck;

    int attempts = reBreak.getValue() ? 1 : 0;
    private BlockPos currentPos;
    private EnumFacing currentFace;
    boolean doSyns = false;
    private long start;
    SwitchUtil switchUtil = new SwitchUtil(silent);
    CalcUtil calcUtil = new CalcUtil();
    private int old,
            delay,
            rebreakCount;
    float mineDamage = 0;
    boolean isPlaced = false;
    boolean isNeedReset = false;
    IBlockState currentState;
    float currentHardness;

    //    public  Setting<ColorMode> colorMode=(new Setting<>("Render Mode", ColorMode.FUTURE,V ->renderMode.getValue() != RenderMode.NONE ));
//    public Setting<Integer> red = (new Setting<>("Red", 255,0,255, v -> colorMode.getValue() == ColorMode.CUSTOM ));
//    public Setting<Integer> green = (new Setting<>("Green", 255,0,255, v -> colorMode.getValue() == ColorMode.CUSTOM ));
//    public Setting<Integer> blue = (new Setting<>("Blue", 255,0,255, v -> colorMode.getValue() == ColorMode.CUSTOM ));
//    public Setting<Integer> alpha = (new Setting<>("Alpha", 255,0,255, v -> colorMode.getValue() == ColorMode.CUSTOM ));
    public SpeedMine() {
        super("SpeedMine", "Mine blocks by packets", Category.EXPLOIT);
        speedMine = this;
    }


    @Override
    public void onEnable() {
        rebreakCount = 0;
        currentPos = null;
        mineDamage = 0;
        isPlaced = false;
    }

//    @EventListener
//    public void onBlockReset(BlockResetEvent event) {
//        if (strict.getValue()) {
//            event.cancel();
//        }
//    }


    @EventListener
    public void onUpdate(MotionEvent.Pre event) {

        if (checkCurrentPos() && !nullCheck() && rotate.getValue()) {

            // mine is complete
            if (mineDamage >= speed.getValue() - 0.05) {
                // send rotations
                rotationManager.doRotation(RotationType.Legit, currentPos, 11);
            }
        }

        if (currentPos != null) {


            if (checkCurrentPos() && mineDamage >= speed.getValue() - 0.05) doSyncAutoCrystal();

//            if (checked) {
//                mineDamage = 0;
//            }

            if (mineDamage <= speed.getValue() && currentPos != null) mineDamage += getBlockStrength(mc.world.getBlockState(currentPos), currentPos);

            if (isPlaced && !resetOnPlace.getValue() || mc.world.getBlockState(currentPos).getBlock() == Blocks.ENDER_CHEST) {
                if (mineDamage >= speed.getValue()) {
                    if (debug.getValue()) Command.sendMessage("I do swap 1");
                    swapTo();
                }
            } else if (mineDamage >= speed.getValue() && mc.world.getBlockState(currentPos).getBlock() != Blocks.AIR) {
                if (debug.getValue()) Command.sendMessage("I do swap 2");
                swapTo();
            } else if (resetOnPlace.getValue() && isPlaced) {
                if (debug.getValue()) Command.sendMessage("I do reset 3");
                resetProgress(false);
                currentPos = null;
                isPlaced = false;
                return;
            }

            if (reBreak.getValue()) {
                if (mc.world.getBlockState(currentPos).getBlock() == Blocks.AIR) {
                    if (!checked) {
                        resetProgress(true);
                        checked = true;
                        strictCheck = false;
                    }
                } else {
                    if (strictReBreak.getValue() && !strictCheck) {
                        Block block = mc.world.getBlockState(currentPos).getBlock();
                        if (!(block.equals(Blocks.ENDER_CHEST) || block.equals(Blocks.ANVIL) || block.equals(Blocks.AIR))) {
                            rebreakCount = 0;
                            mineDamage = 0;
                            currentPos = null;
                            strictCheck = true;
                            return;
                        }
                    }
                    checked = false;
                }

            }

            if (currentPos != null && mc.player.getDistanceSq(currentPos) >= range.getValue() * range.getValue()) {
                resetProgress(false);
                currentPos = null;
            }

        }
        ((IPlayerControllerMP) mc.playerController).setBlockHitDelay(0);
    }

    @EventListener
    public void onBlockReset(BlockResetEvent event) {
        if (noReset.getValue()) event.cancel();
    }

    @EventListener
    public void onBlockEvent(BlockEvent e) {

        if (!canBlockBeBroken(e.getPos())) {
            e.cancel();
            return;
        }


        if (currentPos != null) {
            if (e.getPos() == currentPos) {
                if (mineDamage >= speed.getValue() && mc.world.getBlockState(currentPos).getBlock() != Blocks.AIR) {
                    swapTo();
                    mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, currentPos, EnumFacing.DOWN));
                    e.cancel();
                }
                return;
            }

            if (e.getPos() != currentPos) {
          if(abort.getValue())  mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, currentPos, e.getEnumFacing()));
            }
        }
        ((IPlayerControllerMP) mc.playerController).setHittingBlock(false);
        mc.player.swingArm(EnumHand.MAIN_HAND);
        for (int j = 0; j < spam.getValue(); j++) {
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, e.getPos(), e.getEnumFacing()));
        }

        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, e.getPos(), EnumFacing.DOWN));
        currentPos = e.getPos();
        currentFace = e.getEnumFacing();
        mineDamage = 0;
        strictCheck = true;
//        e.cancel();
    }

    @Override
    public void onAltRender3D(float partialTicks) {
        if (!fullNullCheck() && renderMode.getValue() != RenderMode.None && checkCurrentPos()) {
            AxisAlignedBB bb = mc.world.getBlockState(currentPos).getSelectedBoundingBox(mc.world, currentPos);
            float progress = mineDamage;
            if (mineDamage >= speed.getValue() - 0.05F) {
                if (renderMode.getValue() == RenderMode.Rise) {
                    Renderer3D.drawBoxESP(new AxisAlignedBB(bb.minX, bb.minY, bb.minZ, bb.maxX, bb.minY, bb.maxZ), readyColor.getColor(), 1f, true, true, readyColor.getColor().getAlpha(), 255);
                } else {
                    Renderer3D.drawBoxESP(bb, readyColor.getColor(), 1f, true, true, readyColor.getColor().getAlpha(), 255);
                }
                if (showProgress.getValue()) {
                    RenderUtil.drawText(bb.offset(0.0, (double) (1.0f - 1 / 2.0f) - 0.4, 0.0), "0%");
                }
            } else {

                switch (renderMode.getValue()) {
                    case Fade:
                        Renderer3D.drawBoxESP(bb, new Color((int) (color.getColor().getRed() * Math.abs(progress - 1)), (int) (readyColor.getColor().getGreen() * progress), color.getColor().getBlue()), 1f, true, true, color.getColor().getAlpha(), 255);
                        break;
                    case Expand:
                        Renderer3D.drawProgressBox(bb, 1 - progress, color.getColor());
                        break;
                    case Rise:
                        Renderer3D.drawRiseBox(bb, 1 - progress, new Color((int) (color.getColor().getRed() * Math.abs(progress - 1)), (int) (readyColor.getColor().getGreen() * progress), color.getColor().getBlue(), 75));
                        break;
                }
                if (showProgress.getValue()) {
                    RenderUtil.drawText(bb.offset(0.0, (double) (1.0f - 1 / 2.0f) - 0.4, 0.0), String.format("%.1f%%", progress * 100));
                }

            }
        }
    }


    @EventListener
    public void onPacketSend(PacketEvent.Send event) {
        if (event.getPacket() instanceof CPacketHeldItemChange && strict.getValue() && checkCurrentPos() && !doSyns && mineDamage <= speed.getValue() - 0.05) {
            sendPacket();
            resetProgress(true);
            checked = true;
            ((IPlayerControllerMP) mc.playerController).setBlockHitDelay(0);
            strictCheck = true;
        }
    }

    @EventListener
    public void onRightClick(ProcessRightClickBlockEvent event) {
        if (currentPos == null) return;
        isPlaced = checkPos(event.pos);
    }

    public void doSyncAutoCrystal() {
        if (AutoCrystal.getInstance().isDisabled() || findTarget() == null) return;
        EntityPlayer target = findTarget();
        calcUtil.addAir(currentPos);
        double damage = calcUtil.calculateDamage(currentPos, target);
        if (rotate.getValue()) rotationManager.doRotation(RotationType.Legit, currentPos, 11);
        if (damage > AutoCrystal.getInstance().placeMinDamage.getValue()) doPlace(placeMode.getValue());
        doSyns = false;
    }

    public void doPlace(PlaceMode mode) {
        EnumFacing facing = BlockUtil.getFirstFacing(currentPos);
        doSyns = true;
        switch (mode) {
            case AutoCrystal:
                AutoCrystalQueue autoCrystal = AutoCrystal.getInstance();
                autoCrystal.addPlacePos(currentPos);
                break;
            case Manual:
                placeCrystal();
                break;
        }
    }

    EntityPlayer findTarget() {
        EntityPlayer target = null;
//        for (EntityPlayer temp :  mc.world.playerEntities) {
//            targetManager.addTarget(temp);
//        }
        for (EntityPlayer possibleTarget : mc.world.playerEntities) {
            double distancePos = currentPos.getDistance((int) possibleTarget.posX, (int) possibleTarget.posY, (int) possibleTarget.posZ);
            if (distancePos < 4 && !friendManager.isFriend(possibleTarget.getName()) && mc.player != possibleTarget) {
                target = possibleTarget;
                targetManager.addTarget(possibleTarget);
                break;
            }
        }
        return target;
    }

    public void placeCrystal() {
        int oldslot = mc.player.inventory.currentItem;
        int crystal = InventoryUtil.getItemHotbar(Items.END_CRYSTAL);
        if (crystal != mc.player.inventory.currentItem || !InventoryUtil.heldItem(Items.END_CRYSTAL, InventoryUtil.Hand.Off))
            InventoryUtil.setCurrentItem(crystal);
        mc.player.connection.sendPacket(new CPacketPlayerTryUseItemOnBlock(currentPos, EnumFacing.UP, mc.player.getHeldItemOffhand().getItem() == Items.END_CRYSTAL ? EnumHand.OFF_HAND : EnumHand.MAIN_HAND, 0.5f, 1.0f, 0.5f));
//        InventoryUtil.setCurrentItem(oldslot);
    }

    void swapTo() {
        switchUtil.switchTo(getBestSlot(mc.world.getBlockState(currentPos)));
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, currentPos, currentFace));
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, currentPos, currentFace));
        resetProgress(reset.getValue());
        switchUtil.switchBack();
        if (!reBreak.getValue()) currentPos = null;
    }

    public boolean canBlockBeBroken(final BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        boolean isPos = currentPos == null || !currentPos.equals(pos);
        return (blockState.getBlockHardness(mc.world, pos) >= 0 && mineDamage == 0) || (blockState.getBlockHardness(mc.world, pos) >= 0 && isPos);
    }

    void resetProgress(boolean reset) {
        resetProgress(reset, true);
    }

    void resetProgress(boolean reset, boolean rebreak) {
        if (currentPos == null) return;
        if (reset) {
            if(abort.getValue())   mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, currentPos, currentFace));
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, currentPos, currentFace));
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, currentPos, EnumFacing.DOWN));
        }

        mineDamage = 0;
        if (rebreak) rebreakCount = 0;
    }

    void stopProgress() {
//        if (reset) mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, currentPos, currentFace));
        rebreakCount = 0;
        currentPos = null;
    }

    void sendPacket() {
        if(abort.getValue())   mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, currentPos, currentFace));
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, currentPos, currentFace));
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, currentPos, EnumFacing.DOWN));
    }

    boolean checkPos(BlockPos pos) {
        return (currentPos.equals(pos.up()) || currentPos.equals(pos.down())
                || currentPos.equals(pos.west()) || currentPos.equals(pos.east())
                || currentPos.equals(pos.north()) || currentPos.equals(pos.west()));
    }

    boolean checkCurrentPos() {
        return currentPos != null && SpeedMine.mc.world.getBlockState(currentPos).getBlock() != Blocks.AIR;
    }

    public int getBestSlot(IBlockState state) {

        // the efficient slot
        int bestSlot = -1;

        // find the most efficient item
        double bestBreakSpeed = 0;

        // iterate through item in the hotbar
        for (int i = 0; i < 9; i++) {
            if (!mc.player.inventory.getStackInSlot(i).isEmpty()) {
                float breakSpeed = mc.player.inventory.getStackInSlot(i).getDestroySpeed(state);

                // make sure the block is breakable
                if (breakSpeed > 1) {

                    // scale by efficiency enchantment
                    if (EnchantmentHelper.getEnchantmentLevel(Enchantments.EFFICIENCY, mc.player.inventory.getStackInSlot(i)) > 0) {
                        breakSpeed += StrictMath.pow(EnchantmentHelper.getEnchantmentLevel(Enchantments.EFFICIENCY, mc.player.inventory.getStackInSlot(i)), 2) + 1;
                    }

                    // if it's greater than our best break speed, mc.player our new most efficient item
                    if (breakSpeed > bestBreakSpeed) {
                        bestBreakSpeed = breakSpeed;
                        bestSlot = i;
                    }
                }
            }
        }

        // return the most efficient item
        if (bestSlot != -1) {
            return bestSlot;
        }

        return mc.player.inventory.currentItem;
    }

    public ItemStack getEfficientItem(IBlockState state) {

        // the efficient slot
        int bestSlot = -1;

        // find the most efficient item
        double bestBreakSpeed = 0;

        // iterate through item in the hotbar
        for (int i = 0; i < 9; i++) {
            if (!mc.player.inventory.getStackInSlot(i).isEmpty()) {
                float breakSpeed = mc.player.inventory.getStackInSlot(i).getDestroySpeed(state);

                // make sure the block is breakable
                if (breakSpeed > 1) {

                    // scale by efficiency enchantment
                    if (EnchantmentHelper.getEnchantmentLevel(Enchantments.EFFICIENCY, mc.player.inventory.getStackInSlot(i)) > 0) {
                        breakSpeed += StrictMath.pow(EnchantmentHelper.getEnchantmentLevel(Enchantments.EFFICIENCY, mc.player.inventory.getStackInSlot(i)), 2) + 1;
                    }

                    // if it's greater than our best break speed, mc.player our new most efficient item
                    if (breakSpeed > bestBreakSpeed) {
                        bestBreakSpeed = breakSpeed;
                        bestSlot = i;
                    }
                }
            }
        }

        // return the most efficient item
        if (bestSlot != -1) {
            return mc.player.inventory.getStackInSlot(bestSlot);
        }

        return mc.player.inventory.getStackInSlot(mc.player.inventory.currentItem);
    }

    /**
     * Finds the block strength of a specified block
     *
     * @param state    The {@link IBlockState} block state of the specified block
     * @param position The {@link BlockPos} position of the specified block
     * @return The block strength of the specified block
     */
    public float getBlockStrength(IBlockState state, BlockPos position) {

//        if (mineDamage == 0) {
//            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.ABORT_DESTROY_BLOCK, currentPos, currentFace));
//            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, currentPos, currentFace));
//        }
        // the block's hardness
        float hardness = state.getBlockHardness(mc.world, position);

        // if the block is air, it has no strength
        if (hardness > 0) {
            currentState = state;
            currentHardness = hardness;
            return getDigSpeed(state) / hardness / 30F;
        } else {
            return getDigSpeed(currentState) / currentHardness / 30F;
        }
    }

    /**
     * Finds the dig speed of a specified block
     *
     * @param state {@link IBlockState} The block state of the specified block
     * @return The dig speed of the specified block
     */
    @SuppressWarnings("all")
    public float getDigSpeed(IBlockState state) {

        // base dig speed
        float digSpeed = getDestroySpeed(state);

        if (digSpeed > 1) {
            ItemStack itemstack =  getEfficientItem(state);

            // efficiency level
            int efficiencyModifier = EnchantmentHelper.getEnchantmentLevel(Enchantments.EFFICIENCY, itemstack);

            // scale by efficiency level
            if (efficiencyModifier > 0 && !itemstack.isEmpty()) {
                digSpeed += StrictMath.pow(efficiencyModifier, 2) + 1;
            }
        }


        // scaled based on haste effect level
        if (mc.player.isPotionActive(MobEffects.HASTE)) {
            digSpeed *= 1 + (mc.player.getActivePotionEffect(MobEffects.HASTE).getAmplifier() + 1) * 0.2F;
        }

        if (mc.player.isPotionActive(MobEffects.MINING_FATIGUE)) {

            // scale based on fatigue effect level
            float fatigueScale;
            switch (mc.player.getActivePotionEffect(MobEffects.MINING_FATIGUE).getAmplifier()) {
                case 0:
                    fatigueScale = 0.3F;
                    break;
                case 1:
                    fatigueScale = 0.09F;
                    break;
                case 2:
                    fatigueScale = 0.0027F;
                    break;
                case 3:
                default:
                    fatigueScale = 8.1E-4F;
            }

            digSpeed *= fatigueScale;
        }

        // reduce dig speed if the player is in water
        if (mc.player.isInsideOfMaterial(Material.WATER) && !EnchantmentHelper.getAquaAffinityModifier(mc.player)) {
            digSpeed /= 5;
        }

        // reduce dig speed if the player is not on the ground
        if (!mc.player.onGround) {
            digSpeed /= 5;
        }

        return (digSpeed < 0 ? 0 : digSpeed);
    }

    /**
     * Finds the destroy speed of a specified position
     *
     * @param state {@link IBlockState} The position to get the destroy speed for
     * @return The destroy speed of the specified position
     */
    public float getDestroySpeed(IBlockState state) {

        // base destroy speed
        float destroySpeed = 1;

        // scale by the item's destroy speed
        if (getEfficientItem(state) != null && !getEfficientItem(state).isEmpty()) {
            destroySpeed *= getEfficientItem(state).getDestroySpeed(state);
        }

        return destroySpeed;
    }

    public BlockPos getCurrentPos() {
        return currentPos;
    }

    public static boolean setBlock(BlockPos pos, EnumFacing facing) {
        if (speedMine.isDisabled()) return false;
        if (pos == null || facing == null) return false;
//        speedMine.onBlockEvent(new BlockEvent(0,pos,facing));
        mc.playerController.clickBlock(pos, facing);
        return true;
    }

}